# 투 포인터(다중 포인터) - 알고리즘 패턴 학습(JS)
> 투 포인터 또는 다중 포인터. **두 개 또는 그 이상의 포인터를 두고 값들을 비교하여 문제를 해결하는 알고리즘 패턴**이다.   

간단한 예제와 함께 알고리즘 효율성에 대해서도 알아보자.

<br>

## 예제
> **특정 숫자들이 들어있는 배열이 주어졌을 때, 배열 안에 가장 첫 번째로 두 숫자의 합이 0이 되는 값 2개를 배열에 담아 리턴하는 함수를 만들어보자.**   
> (배열의 값들은 낮은 수부터 정렬되어 있다.)

<br>

```js
// 예시
getSumZero([-2, -1, 1, 2, 3]); // [-2, 2] => 배열에서 두 숫자의 합이 0이 되는 가장 첫 번째 수는 -2와 2이다.
getSumZero([-1, 0, 1, 2]); // [-1, 1]
getSumZero([0, 1, 2, 3]); // false => 두 숫자의 합이 0이 되는 숫자는 없다.
```

<br>

흔히 생각하는 방법과 투 포인터라는 알고리즘 패턴을 통해 풀어 보려 한다.

<br>

### 흔히 생각하는 방법
```js
function getSumZero(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] + arr[j] === 0) {
        return [arr[i], arr[j]];
      }
    }
  }

  return false;
}
```

<br>

보통은 `for`문 안에 `for`문을 넣어 푸는 이중 `for`문 방식으로 두 값의 합이 0인 경우를 찾아서 리턴하여 풀 수 있을 것이다. 그리고 조건문에 걸리지 않으면 최종적으로 `false`를 리턴하여 마무리한다.

이 방법은 배열 안에 여러 값들을 비교할 때 아마 흔히 사용하는 방법일 것이다. 그리고 코드도 짧고 가독성도 나쁘지 않은 것 같다.

그러나 역시 이중 `for`문이 가진 단점이라 한다면 시간 복잡도가 `O(n^2)`이라는 것이다.

이때 시간 복잡도를 효율적으로 가져갈 수 있는 것이 투 포인터이다.

<br>

## 투 포인터의 개념
```js
// 포인터 2개를 각 p1, p2라고 하겠다.

// [-2, -1, 1, 2, 3]
//  p1
//               p2

// 1. p1과 p2의 합을 구한다. (-2 + 3 = 1)
// 2. 합이 0인가? => 해당 값 리턴
// 3. 합이 0보다 작은가? => p1을 한 칸 올린다.
// 4. ✅ 합이 0보다 큰가? => p2를 한 칸 내린다. (합이 0보다 큰 1이다)

// [-2, -1, 1, 2, 3]
//  p1
//            p2

// 1. 다시 위에 1 ~ 4번 과정을 반복
// 2. ✅ 합이 0인가? => 해당 값 리턴 ([-2, 2])

```

<br>

이런 식으로 2개의 포인터를 만들어서 조건에 의해 움직이면 된다. 이 방법으로 진행한다면 하나의 반복문에서 문제를 해결할 수 있다.
아래는 해당 형식으로 작성한 풀이다.

<br>

### O(n)의 시간 복잡도로 풀어보기
```js
function getSumZero(arr) {
  let p1 = 0;
  let p2 = arr.length - 1; // p2는 주어진 배열의 맨 뒤에서 부터 시작.

  while (p1 !== p2) { // p1과 p2가 만나면 모든 값을 확인 했으니 반복문 종료.
    const result = arr[p1] + arr[p2];

    if (result === 0) { // 두 값의 합이 0이면 바로 리턴.
      return [arr[p1], arr[p2]];
    }

    if (result > 0) { // 0 보다 크면 p2를 한 칸 내림.
      p2--;
    } else { // 그게 아니면(0보다 작으면) p1을 한 칸 올림.
      p1++;
    }
  }

  return false;
}
```

<br>

위 방법은 `p1`과 `p2`가 만나는 시점, 즉 결국에 배열 안에 값들을 한 번씩만 확인하면 되기 때문에 `O(n)`이라는 시간 복잡도를 가진다.
그래서 처음 풀이보다 효율적인 시간 복잡도를 가진다.
